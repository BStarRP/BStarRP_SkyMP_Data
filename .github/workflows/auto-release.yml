# Create a release with version from Conventional Commits when patch-content/ changes.
# fix: → PATCH, feat: → MINOR, BREAKING CHANGE / ! → MAJOR (https://www.conventionalcommits.org/)
# The Build patch workflow then attaches the zip to this release.

name: Auto release on patch change

on:
  push:
    branches: [main]
    paths:
      - 'patch-content/**'

jobs:
  auto-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version bump from commits
        id: bump
        run: |
          set -e
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          LOG=$(git log "$LATEST_TAG..HEAD" --format="%s%n%b" -- patch-content/ || true)
          BUMP=patch
          # BREAKING CHANGE in body, or type! in subject (e.g. feat!:) → major
          if echo "$LOG" | grep -qi 'BREAKING CHANGE'; then
            BUMP=major
          elif echo "$LOG" | grep -qE '^[a-z]+!.*:'; then
            BUMP=major
          # feat: or feat(scope): → minor
          elif echo "$LOG" | grep -qE '^feat(\([^)]*\))?:'; then
            BUMP=minor
          # fix: or fix(scope): → patch
          elif echo "$LOG" | grep -qE '^fix(\([^)]*\))?:'; then
            BUMP=patch
          fi
          echo "bump=$BUMP" >> $GITHUB_OUTPUT
          echo "Bump type: $BUMP"

      - name: Get latest version and compute new version
        id: version
        run: |
          LATEST=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          VERSION=${LATEST#v}
          MAJOR=$(echo "$VERSION" | cut -d. -f1)
          MINOR=$(echo "$VERSION" | cut -d. -f2)
          PATCH=$(echo "$VERSION" | cut -d. -f3)
          [[ -z "$PATCH" ]] && PATCH=0
          case "${{ steps.bump.outputs.bump }}" in
            major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
            minor) MINOR=$((MINOR + 1)); PATCH=0 ;;
            patch) PATCH=$((PATCH + 1)) ;;
          esac
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      - name: Generate patch notes from commits
        id: notes
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          VERSION="${{ steps.version.outputs.version }}"
          NOTES="# Patch $VERSION"$'\n\n'
          FEATURES=""
          FIXES=""
          BREAKING=""
          while IFS= read -r subject; do
            [[ -z "$subject" ]] && continue
            desc=$(echo "$subject" | sed -E 's/^[a-z]+(\([^)]*\))?!?:\s*//')
            if echo "$subject" | grep -qiE '^[a-z]+!.*:' || echo "$subject" | grep -qi 'BREAKING'; then
              BREAKING="$BREAKING- $desc"$'\n'
            elif echo "$subject" | grep -qE '^feat(\([^)]*\))?:'; then
              FEATURES="$FEATURES- $desc"$'\n'
            elif echo "$subject" | grep -qE '^fix(\([^)]*\))?:'; then
              FIXES="$FIXES- $desc"$'\n'
            else
              FIXES="${FIXES}- $subject"$'\n'
            fi
          done < <(git log "$LATEST_TAG..HEAD" --format="%s" --reverse -- patch-content/)
          [[ -n "$BREAKING" ]] && NOTES="${NOTES}### Breaking Changes"$'\n'"$BREAKING"$'\n'
          [[ -n "$FEATURES" ]] && NOTES="${NOTES}### Features"$'\n'"$FEATURES"$'\n'
          [[ -n "$FIXES" ]] && NOTES="${NOTES}### Fixes"$'\n'"$FIXES"
          echo "${NOTES}" > release-notes.md
          echo "Generated patch notes:"
          cat release-notes.md

      - name: Create release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create ${{ steps.version.outputs.tag }} \
            --title "Patch ${{ steps.version.outputs.version }}" \
            --notes-file release-notes.md \
            --latest